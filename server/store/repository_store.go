package store

import (
	"database/sql"
	"log"
	"time"

	pb "github.com/EdmilsonRodrigues/ophelia-ci"
	"github.com/google/uuid"
	_ "github.com/mattn/go-sqlite3"
	"google.golang.org/protobuf/types/known/timestamppb"
)

type SQLRepositoryStore struct {
	db *sql.DB
}

type RepositoryStore interface {
	CreateTable() error
	CreateRepository(repo *pb.CreateRepositoryRequest) (pb.RepositoryResponse, error)
	GetRepository(id string) (*pb.RepositoryResponse, error)
	GetRepositoryByName(name string) (*pb.RepositoryResponse, error)
	UpdateRepository(repo *pb.UpdateRepositoryRequest) (pb.RepositoryResponse, error)
	ListRepositories() (pb.ListRepositoryResponse, error)
	DeleteRepository(id string) error
}

// NewSQLRepositoryStore creates a new SQLRepositoryStore given a database connection.
//
// If the repositories table does not exist in the database, it will be created.
//
// The function will log a fatal error if there is an issue creating the table.
func NewSQLRepositoryStore(db *sql.DB) *SQLRepositoryStore {
	store := &SQLRepositoryStore{
		db: db,
	}
	err := store.CreateTable()
	if err != nil {
		log.Fatalf("Failed to create repositories table: %v", err)
	}
	return store
}

// CreateTable creates the repositories table in the SQLite database if it does not exist.
//
// The repositories table has the following columns:
// - id: the ID of the repository, which is the primary key
// - name: the name of the repository
// - description: the description of the repository
// - last_update: the timestamp when the repository was last updated
//
// Returns an error if there is an issue creating the table.
func (s *SQLRepositoryStore) CreateTable() error {
	log.Println("Creating repositories table...")
	query := `
        CREATE TABLE IF NOT EXISTS repositories (
            id TEXT PRIMARY KEY,
            name TEXT NOT NULL,
            description TEXT,
            last_update INTEGER
        );
    `
	_, err := s.db.Exec(query)
	if err != nil {
		log.Println("Error creating repositories table:", err)
		return err
	}
	return nil
}

// CreateRepository creates a new repository with the given information.
//
// The request must contain the repository name and description.
// The ID is generated by the server.
// The LastUpdate is set to the current timestamp by the server.
//
// The response will contain the created repository information.
//
// Parameters:
// - repo: The request containing the repository information.
//
// Returns:
// - *pb.RepositoryResponse: The response containing the created repository information.
// - error: An error if there is an issue creating the repository.
func (s *SQLRepositoryStore) CreateRepository(repo *pb.CreateRepositoryRequest) (pb.RepositoryResponse, error) {
	id := uuid.New().String()
	now := timestamppb.Now()
	query := "INSERT INTO repositories (id, name, description, last_update) VALUES (?, ?, ?, ?)"
	_, err := s.db.Exec(query, id, repo.Name, repo.Description, now.Seconds)
	log.Printf("Inserting repository %v with id %v into database...\n", repo.Name, id)
	if err != nil {
		log.Println("Error inserting repository:", err)
		return pb.RepositoryResponse{}, err
	}
	return pb.RepositoryResponse{
		Id:          id,
		Name:        repo.Name,
		Description: repo.Description,
		LastUpdate:  now,
	}, nil
}

// GetRepository gets a repository by ID.
//
// The request must contain the repository ID.
//
// The response will contain the repository information.
//
// Parameters:
// - id: The ID of the repository to retrieve.
//
// Returns:
// - *pb.RepositoryResponse: The response containing the repository information.
// - error: An error if there is an issue retrieving the repository.
func (s *SQLRepositoryStore) GetRepository(id string) (*pb.RepositoryResponse, error) {
	query := "SELECT id, name, description, last_update FROM repositories WHERE id = ?"
	var repo pb.RepositoryResponse
	var lastUpdateSeconds int64
	row := s.db.QueryRow(query, id)
	err := row.Scan(&repo.Id, &repo.Name, &repo.Description, &lastUpdateSeconds)
	log.Printf("Getting repository with id %v from database...\n", id)
	if err != nil {
		log.Println("Error getting repository:", err)
		return nil, err
	}
	repo.LastUpdate = timestamppb.New(time.Unix(lastUpdateSeconds, 0))
	return &repo, err
}

// GetRepositoryByName retrieves a repository by its name from the database.
//
// Parameters:
// - name: The name of the repository to retrieve.
//
// Returns:
// - *pb.RepositoryResponse: The response containing the repository information.
// - error: An error if there is an issue retrieving the repository.
func (s *SQLRepositoryStore) GetRepositoryByName(name string) (*pb.RepositoryResponse, error) {
	query := "SELECT id, name, description, last_update FROM repositories WHERE name = ?"
	var repo pb.RepositoryResponse
	var lastUpdateSeconds int64
	row := s.db.QueryRow(query, name)
	err := row.Scan(&repo.Id, &repo.Name, &repo.Description, &lastUpdateSeconds)
	if err != nil {
		return nil, err
	}
	repo.LastUpdate = timestamppb.New(time.Unix(lastUpdateSeconds, 0))
	return &repo, nil
}

// UpdateRepository updates an existing repository with the given information.
//
// The request must contain the repository ID, name and description.
// The ID is used to identify the repository to be updated.
// The name and description are used to update the repository information.
//
// The response will contain the updated repository information.
//
// Parameters:
// - repo: The request containing the repository ID, name and description.
//
// Returns:
// - *pb.RepositoryResponse: The response containing the updated repository information.
// - error: An error if there is an issue updating the repository.
func (s *SQLRepositoryStore) UpdateRepository(repo *pb.UpdateRepositoryRequest) (pb.RepositoryResponse, error) {
	now := timestamppb.Now()
	query := "UPDATE repositories SET name = ?, description = ?, last_update = ? WHERE id = ?"
	_, err := s.db.Exec(query, repo.Name, repo.Description, now.Seconds, repo.Id)
	log.Printf("Updating repository with id %v in database...\n", repo.Id)
	if err != nil {
		log.Println("Error updating repository:", err)
		return pb.RepositoryResponse{}, err
	}
	return pb.RepositoryResponse{
		Id:          repo.Id,
		Name:        repo.Name,
		Description: repo.Description,
		LastUpdate:  now,
	}, nil
}

// ListRepositories lists all existing repositories in the database.
//
// The response will contain a list of existing repositories.
//
// Returns:
// - *pb.ListRepositoryResponse: The response containing the list of repositories.
// - error: An error if there is an issue listing repositories.
func (s *SQLRepositoryStore) ListRepositories() (repos pb.ListRepositoryResponse, err error) {
	query := "SELECT id, name, description, last_update FROM repositories"
	rows, err := s.db.Query(query)
	log.Println("Getting all repositories from database...")
	if err != nil {
		return
	}
	defer rows.Close()
	for rows.Next() {
		var repo pb.RepositoryResponse
		var lastUpdateSeconds int64
		err = rows.Scan(&repo.Id, &repo.Name, &repo.Description, &lastUpdateSeconds)
		if err != nil {
			log.Println("Error scanning repository:", err)
			return
		}
		repo.LastUpdate = timestamppb.New(time.Unix(lastUpdateSeconds, 0))
		repos.Repositories = append(repos.Repositories, &repo)
	}
	return
}

// DeleteRepository deletes a repository with the specified ID from the database.
//
// Parameters:
// - id: The ID of the repository to be deleted.
//
// Returns:
// - error: An error if there is an issue deleting the repository.
func (s *SQLRepositoryStore) DeleteRepository(id string) (err error) {
	query := "DELETE FROM repositories WHERE id = ?"
	_, err = s.db.Exec(query, id)
	log.Printf("Deleting repository with id %v from database...\n", id)
	if err != nil {
		log.Println("Error deleting repository:", err)
		return
	}
	return
}
